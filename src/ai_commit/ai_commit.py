import subprocess
import textwrap
import openai
from openai import OpenAI
import click
import os
import tempfile

@click.command()
def main():
    """
    This script generates a git commit message using OpenAI GPT based on the output of `git diff --cached`.
    """
    api_key = os.getenv('OPENAI_API_KEY')
    if not api_key:
        click.echo("Error: OPENAI_API_KEY environment variable not set.", err=True)
        exit(1)

    openai.api_key = api_key
    changes = get_git_changes()

    if not changes:
        click.echo("No changes to commit.")
        return

    commit_message = generate_commit_message(changes)
    commit_message = format_commit_message(commit_message)
    edit_commit_message(commit_message)

def get_git_changes():
    result = subprocess.run(['git', 'diff', '--cached'], capture_output=True, text=True)
    return result.stdout

def generate_commit_message(changes):
    try:
        client = OpenAI()

        print("Generating commit message.....")
        instructions = (
            "You are an AI assistant. Generate a git commit message from the provided diff. "
            "Follow these formatting rules:\n"
            "- Start with a summary line of no more than 60 characters.\n"
            "- Then a blank line.\n"
            "- Follow with a paragraph describing the changes, keeping the max line length at 80 characters.\n"
            "- Describe changes imperatively, e.g., 'Add feature X', 'Fix bug Y'.\n"
            "- Do not mention changes to imports.\n"
            "- Do not mention that the message was generated by AI.\n"
            "- Do not say things like 'these changes improve readibiity'"
            "- Do not use triple quotes or other markdown formatting"
            "- Only include the commit message, not any additional commentary"
            "Here is the diff:\n" + changes
        )

        stream = client.chat.completions.create(
            model="gpt-3.5-turbo-1106",
            messages=[
                {
                    "role": "user",
                    "content": instructions
                },
                {
                    "role": "user",
                    "content": "here is the diff: " + changes
                }
            ],
            stream=True,
            temperature=0
        )
        
        commit_message = ""
        for part in stream:
            commit_message += part.choices[0].delta.content or ""

        return commit_message
    except Exception as e:
        click.echo("Error in generating commit message: " + str(e), err=True)
        exit(1)

def format_commit_message(commit_message):
    lines = commit_message.split('\n')
    formatted_message = []

    # Process summary line (first line, up to 60 chars)
    if lines:
        formatted_message.append(lines[0][:60])

    # Process the rest of the message (up to 80 chars per line)
    for line in lines[1:]:
        wrapped_lines = textwrap.wrap(line, width=80)
        formatted_message.extend(wrapped_lines)

    return '\n'.join(formatted_message)

def edit_commit_message(commit_message):
    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as tmp_file:
        tmp_file.write(commit_message)
        tmp_file_path = tmp_file.name

    editor = subprocess.check_output(['git', 'var', 'GIT_EDITOR']).strip().decode('utf-8')
    subprocess.call([editor, tmp_file_path])

    with open(tmp_file_path, 'r') as file:
        final_commit_message = ""
        for line in file:
            if not line.strip().startswith('#'):
                final_commit_message += line


    if not final_commit_message.strip():
        click.echo("Commit aborted: no commit message provided after editing.")
        return

    subprocess.call(['git', 'commit', '-F', tmp_file_path])
    os.unlink(tmp_file_path)


if __name__ == "__main__":
    main()
